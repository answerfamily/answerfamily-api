type Query {
  # List all paragraphs that meet the filter
  paragraphs(
    filter: ParagraphSearchFilter
    sort: [ParagraphSearchSort]
    first: Int
    skip: Int
  ): [Paragraph]

  # List all paragraphReplies
  paragraphReplies(
    first: Int
    skip: Int
  ): [ParagraphReply]

  replies(
    filter: ReplySearchFilter
    sort: [ReplySearchSort]
    first: Int
    skip: Int
  ): [Reply]

  # Get single aritcle
  article(id: String!): Article

  # Get single paragraph
  paragraph(id: String!): Paragraph

  # Get single reply
  reply(id: String!): Reply

  # Get currently logged-in user. null if not logged in.
  me: CurrentUser
}

type Mutation {
  createArticle(article: ArticleInput): Article
  addParagraphToArticle(articleId: String!, paragraph: ParagraphInput!): Article
  addSourceToArticle(articleId: String!, source: ArticleSourceInput!): Article

  # Deletes paragraph and all its paragraphReplies. Reply would remain.
  deleteParagraph(paragraphId: String!): Article

  deleteSource(sourceId: ObjectId!): Article

  # Connects existing reply with a paragraph
  connectReplyWithParagraph(replyId: String!, paragraphId: String!): Paragraph
  disconnectReplyAndParagraph(replyId: String!, paragraphId: String!): Paragraph

  addReplyToParagraph(paragraphId: String!, reply: ReplyInput!): Paragraph
}

"""
Actual article text being circulated.
May be LINE messages, text from flyers, etc.
"""
type Article {
  id: String
  text: String
  paragraphs: [Paragraph]
  sources: [ArticleSource]
  createdAt: String
  user: User
}

input ArticleInput {
  text: String!
  paragraphs: [ParagraphInput]
  sources: [ArticleSourceInput]
}

"""
Replied paragraph from an article
"""
type Paragraph {
  id: String
  text: String
  createdAt: String
  article: Article
  paragraphReplies: [ParagraphReply]
  user: User

  # If the current user can delete this paragraph
  canDelete: Boolean
}

input ParagraphInput {
  text: String!,

  # Re-use existing replies
  replyIds: [String]
}

"""
Connection between paragraphs and replies.
One paragraph may have multiple replies, and a reply can be used in multiple paragraphs.
"""
type ParagraphReply {
  id: ObjectId
  paragraph: Paragraph
  reply: Reply
  user: User
  createdAt: String

  # If the current user can delete this paragraphReply
  canDelete: Boolean
}

"""
Reply to a paragraph
"""
type Reply {
  id: String
  text: String
  user: User

  # author's note, for other editors to see
  note: String

  createdAt: String

  paragraphReplies: [ParagraphReply]
}

input ReplyInput {
  text: String!
  note: String
}

"""
Where the article is from
"""
type ArticleSource {
  id: ObjectId

  article: Article

  # author's note of this source for other editors, probably indicating how the article can be retrieved
  note: String
  url: String

  # The person that reports such occurrence
  user: User

  canDelete: Boolean

  createdAt: String
}

input ArticleSourceInput {
  # author's note of this source for other editors, probably indicating how the article can be retrieved
  note: String
  url: String
}

"""
User object from Auth0 JWT
"""
type CurrentUser {
  # openid sub claim; user_id on auth0
  id: String
  picture: String
  name: String
  email: String
}

"""
Publuc user profile from auth0
"""
type User {
  # user in DB
  id: String
  picture: String
  name: String
}

input ParagraphSearchFilter {
  # matches only paragraphs that is inside the given text
  inText: String,

  # matches only paragraphs that contains these terms
  contain: String,
}

input ReplySearchFilter {
  # matches only paragraphs that contains these terms
  contain: String,
}

"""
Sort order for search results
"""
enum SortOrder {
  DESC
  ASC
}

enum ParagraphSearchSortBy {
  createdAt

  # Search result relevance
  _score
}

input ParagraphSearchSort {
  by: ParagraphSearchSortBy!
  order: SortOrder
}

enum ReplySearchSortBy {
  createdAt

  # Search result relevance
  _score
}

input ReplySearchSort {
  by: ReplySearchSortBy!
  order: SortOrder
}

"""
This scalar uses MongoDB object ID on server side
and coerce to string on client slide.
"""
scalar ObjectId
